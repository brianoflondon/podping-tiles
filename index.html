<html>

<head>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podping on Hive</title>

    <!-- Favicon -->
    <link rel="icon" href="favicon.ico" type="image/x-icon">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Podping on Hive">
    <meta property="og:description" content="Visualize a non stop stream of podcasts updating.
Powered by the Hive Blockchain and Podcasting 2.0">
    <meta property="og:image" content="/podping-tiles-screenshot.jpg">
    <meta property="og:url" content="https://tiles.podping.org/">
    <meta property="og:type" content="website">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Podping on Hive">
    <meta name="twitter:description" content="Visualize a non stop stream of podcasts updating.
Powered by the Hive Blockchain and Podcasting 2.0">
    <meta name="twitter:image" content="podping-tiles-screenshot.jpg">
    <meta name="twitter:url" content="https://tiles.podping.org/">

    <!-- Local dhive.js -->
    <script src="libs/dhive.js"></script>
</head>

<body>
    <div class="fixed-footer">
        <strong>
            <span class="large-text">
                <a href="https://podping.org" target="_blank">Podping</a>
                running on the
                <a href="https://hive.io" target="_blank">Hive Blockchain</a>
            </span>
            <button class="fancy-button" id="playPauseButton" onclick="togglePlayPause()">||</button>
            <br>
            <span>❇️ </span>
            <span id="blockNumberText" class="small-text">
                Block Number
            </span>
            <span>❇️ </span>
            <span id="podpingCountText" class="small-text">
                Podpings: 0 Podcasts: 0
            </span>
            <br>
            <span>
                ❇️ Running Time: <span id="runningTime">0</span>
            </span>
        </strong>
    </div>
    <script>
        const V4V_API = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
            ? 'http://localhost:1818/v1'
            : 'https://devapi.v4v.app/v1';

        const V4V_PROXY = V4V_API + '/pi/?client_app=podping_tiles&call=';

        var client = new dhive.Client(["https://api.deathwing.me", "https://api.hive.blog", "https://hive-api.arcange.eu", "https://api.openhive.network", "https://techcoderx.com", "https://hive-api.3speak.tv", "https://hiveapi.actifit.io", "https://rpc.mahdiyari.info"]);
        checkApi("startup");

        let isPaused = false;
        const imageLimit = 50;
        let imageCount = 0;
        let podpingCount = 0;
        let podcastCount = 0;
        let startTime = Date.now();
        const imageContainer = document.createElement('div');
        document.body.appendChild(imageContainer);

        const podPingOpsFilter = (op) => {
            if (op.op[0] != 'custom_json' || !op.op[1].id || !op.op[1].id.startsWith('pp_')) {
                return false;
            }
            podpingCount++;
            return true;
        }

        const handlePodPingOps = async (ops) => {
            for (const op of ops) {
                updateBlockNumber(op.block);
                await waitForResume();
                let custom_json_body = '';
                try {
                    custom_json_body = JSON.parse(op.op[1].json);
                } catch (error) {
                    console.error("invalid JSON");
                }

                if (!custom_json_body.iris) {
                    continue;
                }

                const irisArray = custom_json_body.iris;
                for (const feedUrl of irisArray) {
                    const proxiedUrl = encodeURIComponent('podcasts/byfeedurl?url=' + feedUrl);

                    var opts = {
                        method: 'get',
                        headers: {
                            "Content-Type": "application/xml"
                        }
                    };
                    podcastCount++;
                    // Add random delay between 0 and 3 seconds in 0.5-second intervals
                    const delayIntervals = [0, 500, 1000, 1500, 2000, 2500, 3000];
                    const delay = delayIntervals[Math.floor(Math.random() * delayIntervals.length)];
                    await new Promise(resolve => setTimeout(resolve, delay));

                    try {
                        const response = await fetch(V4V_PROXY + proxiedUrl, opts);
                        if (!response.ok) {
                            throw new Error(`Response status: ${response.status}`);
                        }

                        const data = await response.json();
                        const imageUrl = data.feed.artwork;
                        const feedTitle = data.feed.title;
                        const feedLink = data.feed.link; // Extract the link
                        const itunesId = data.feed.itunesId;

                        if (!imageUrl || typeof imageUrl === 'undefined') {
                            continue;
                        }
                        var newImg = document.createElement("img");
                        newImg.setAttribute('src', imageUrl);
                        const altText = itunesId ? `${feedTitle} (episodes.fm link)` : feedTitle;
                        console.log(altText);
                        newImg.setAttribute('alt', altText);
                        newImg.setAttribute('title', feedTitle);

                        var anchor = document.createElement("a");
                        if (itunesId) {
                            anchor.setAttribute('href', `https://episodes.fm/${itunesId}`);
                        } else {
                            anchor.setAttribute('href', feedLink); // Set the link
                        }

                        anchor.setAttribute('target', '_blank'); // Open link in a new tab
                        anchor.appendChild(newImg);
                        imageContainer.insertBefore(anchor, imageContainer.firstChild);

                        // Increment image count and remove oldest images if limit is exceeded
                        imageCount++;
                        if (imageCount > imageLimit) {
                            const oldestImage = imageContainer.querySelector('a:last-child');
                            if (oldestImage) {
                                imageContainer.removeChild(oldestImage);
                                imageCount--;
                            }
                        }
                    } catch (error) {
                        console.log('Rate limit exceeded. Pausing for 60 seconds.');
                        await new Promise(resolve => setTimeout(resolve, 60000));

                        // // if error is rate limit then pause for 10 seconds
                        // if (error.message.includes('429')) {
                        // }
                    }
                }
            }
        }

        const togglePlayPause = () => {
            isPaused = !isPaused;
            document.getElementById('playPauseButton').innerText = isPaused ? '▶' : '||';
            if (!isPaused) {
                checkApi("resume");
                // change class of button to show it is paused
                document.getElementById('playPauseButton').classList.remove('paused');
            } else {
                checkApi("pause");
                // change class of button to show it is playing
                document.getElementById('playPauseButton').classList.add('paused');

            }
        };

        function updateBlockNumber(blockNumber) {
            // block number link: https://hivehub.dev/b/88198226
            const blockNumberLink = `https://hivehub.dev/b/${blockNumber}`;
            var blockNumberAnchor = document.createElement("a");
            blockNumberAnchor.setAttribute('href', blockNumberLink);
            blockNumberAnchor.setAttribute('target', '_blank');
            blockNumberAnchor.innerText = `Block Number: ${blockNumber}`;
            document.getElementById('blockNumberText').innerHTML = '';
            document.getElementById('blockNumberText').appendChild(blockNumberAnchor);
            let elapsedTime = Date.now() - startTime;
            document.getElementById('runningTime').innerText = formatElapsedTime(elapsedTime);
            let podpingsPerMinute = podpingCount / (elapsedTime / 60000);
            document.getElementById('podpingCountText').innerText = `Podpings: ${podpingCount} Podcasts: ${podcastCount} Podpings/Min: ${podpingsPerMinute.toFixed(0)}`;
            // document.getElementById('blockNumberText').innerText = `Block Number: ${blockNumber}`;
        }

        function checkApi(action = "") {
            fetch(V4V_API + '?get_crypto=false&tiles_podping=true&action=' + action)
                .then(response => response.json())
                .then(data => console.log(data))
                .catch(error => console.log(error));
        }

        async function waitForResume() {
            if (isPaused) {
                console.log('paused');
                await new Promise(resolve => {
                    const interval = setInterval(() => {
                        if (!isPaused) {
                            clearInterval(interval);
                            resolve();
                        }
                    }, 100);
                });
                console.log('resumed');
            }
        }

        function formatElapsedTime(elapsedTime) {
            const hours = Math.floor(elapsedTime / 3600000);
            const minutes = Math.floor((elapsedTime % 3600000) / 60000);
            const seconds = Math.floor((elapsedTime % 60000) / 1000);

            const formattedHours = String(hours).padStart(2, '0');
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');

            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        }


        // main loop
        (async function () {
            // get head block number
            const dgp = await client.database.getDynamicGlobalProperties();

            // fetch ops for last 20 blocks
            for (let blockNum = dgp.head_block_number - 20; blockNum < dgp.head_block_number - 1; blockNum++) {
                const ops = await client.database.getOperations(blockNum)
                const pp_ops = ops.filter(podPingOpsFilter);
                handlePodPingOps(pp_ops);
            }

            // stream forever
            for await (const op of client.blockchain.getOperations()) {
                await waitForResume();
                const ops = [op];
                const pp_ops = ops.filter(podPingOpsFilter);
                handlePodPingOps(pp_ops);
            }

        })();
    </script>
</body>

</html>